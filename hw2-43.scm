; in the original the recursive call happens before the flat-map, this is because
; the iterator for the flat map is generated by the recursive call, so in the original
; the recursive calls continue till they hit the base case, at that point the second map
; is executed and completes n iterations, then the filter occurs and the whole thing returns the
; result up the tree to the previous calls flat mapper, so at each layer failed branches are weeded
; out and no computational resources are allocated to calculating them further

; now lets look at the reversed version, in this version the flat mapper fires immediately and
; starts a tree recursion, the base case isn't hit until it hits a leaf, in this case then it progresses
; "branches in" instead of "trunk out" this expends way more computational resources because if a
; particular branch will eventually end in 10 leaves the first procedure will prune all of those
; leaves at once with one prune, i.e. one filter function, in contrast the reversed procedure will
; have to prune each one of those leaves separately

; moreover, after reading this: https://wizardbook.wordpress.com/2010/12/03/exercise-2-43/
; i realized that there is also a huge difference in the number of calls to
; queen-cols, as he points out in the original version there are N+1 calls to the queen-col
; so for n = 3 there are 4 calls to queen-cols, for the reversed version there are *16* calls to
; queen-cols as illustated in factorial_recursion_tree.pdf, (at first i suspected that this is N! + N+1th triangle number)
; of course there is a little bit of a trade off in that calls out towards the leaves will not have to
; go through N iterations but all told the iterations will be way more *and* there will many times as
; many calls to the filter function as discussed earlier

; the number of calls to the function follows this recursive definition:
; let the number of calls at B = calls(B)
; the number of calls at N is (calls(N-1) * N) + 1 unless N = 0 in which case the number of calls is 1
