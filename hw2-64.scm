; so, as best as i can tell the procedure works like this:
; first the procedure is called on a list of numbers
; partial-tree is then passed the list as well as the length of the list
; at this point the procedure calculates the length of one "half" of the list
; the length of one "half" is the length of the list minus one divided by two,
; this is because the central element is the top level node and will not be on either
; the left half or the right half

; then the procedure calls itself on the left 'half' of the list
; with the full list of elements present, it recieves back the outcome of this
; call and pulls the result off the front of the left-result and the list of remaining
; elements off the back half of the result, from this list it pulls off the
; first element and lets this equal the center element, it then takes the remaining elements
; and calls partial-tree on them with a length 'right length', generated by subtracting the left
; length and the center element length (i.e. 1) from the length of element list as a whole

; when the procedure hits a situation where n is 2 it will append the left most
; element and recall itself on the remaining right portion of the list
; in other words, it will create a single node with one right pointing branch that
; leads off to the remainder of the list

; when the procedure hits a situation where n is 1 it will simply create a new node which will obviously
; point off to nothing

; when it hits an even number greater than four it will still pivot around a 'center' element,
; it will just do so by placing one less node in the left side than it does in the right,
; this makes more sense than having a single node pointing off to the remainder of the nodes
; because it makes more nodes available fewer steps down the tree

; so for instance, when the procedure is called on a list that contains five elements
; then it will first pivot around the center element (obiously) then it will call itself
; on both of the two halves that have 2 elements, when this happens it will see that there are
; an even number of elements (not the right number to place a pivot around) it will then append
; the leftmost element and call again on the remaining list, when this happens it will be recalling
; on a list with length one, since there are not enough elements here to pivot around
; it will simply append this element and then return to the top level call

; so the tree would look like this:




;          X                X
;        /                 /
;      X                X
;        -  -  -X-  -  -


; tree generated from calling it with a nine membered list would be



;               X         X
;              /         /
;      X      X    X    X
;        \   /      \  /
;          X         X
;             \    /
;                X


; eleven membered list would be

;        X       X   X      X
;       /       /   /     /
;      X      X    X    X
;        \   /      \  /
;          X         X
;             \    /
;                X

; as for the time complexity i am actually pretty certain that this runs in O(N)
; since it hits each node only once
